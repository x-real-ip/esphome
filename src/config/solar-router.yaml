---
<<: !include common/base.yaml

logger:
  level: DEBUG

substitutions:
  device_name: "solar-router"
  device_comment:
    "Routes surplus solar power to a heating element to heat water or for space
    heating"

esphome:
  name: ${device_name}
  comment: ${device_comment}
  includes:
    - solar-router.h
  on_boot:
    priority: -10
    then:
      - lambda: |-
          dac_set_output_range(id(i2cbus), id(dac_addr_reg));
          dac_set_voltage(id(i2cbus), id(dac_addr_reg), 0.0);

esp32:
  board: esp32dev
  framework:
    type: esp-idf

button:
  - <<: !include common/button/restart.yaml

binary_sensor:
  - <<: !include common/binary_sensor/status.yaml

text_sensor:
  - <<: !include common/text_sensor/version.yaml
  - <<: !include common/text_sensor/wifi_info.yaml

sensor:
  - <<: !include common/sensor/uptime.yaml
  - <<: !include common/sensor/wifi_signal.yaml

  - platform: mqtt_subscribe
    id: grid_power_returned
    # topic: "dsmr/reading/electricity_currently_returned"
    topic: "dsmr/reading/electricity_currently_delivered" # Test Topic
    unit_of_measurement: "W"
    internal: true
    on_value:
      - lambda: |-
          if (!id(manual_mode)) {
            id(power_value) = x;
            id(power).publish_state(x);  // updates the input number (slider)
          }

  - platform: mqtt_subscribe
    id: grid_voltage
    topic: "dsmr/reading/phase_voltage_l1"
    unit_of_measurement: "V"
    internal: true

i2c:
  sda: 21
  scl: 22
  scan: true
  id: i2cbus

mqtt:
  broker: "mqtt.lan.stamx.nl"
  username: !secret mqtt_user
  password: !secret mqtt_password
  discovery: false

output:
  - platform: gpio
    id: ssr_relay_1
    pin: 25

globals:
  - id: dac_addr_reg
    type: uint8_t
    restore_value: false
    initial_value: "0x58"

  - id: dac_duty_cycle_reg
    type: uint8_t
    restore_value: false
    initial_value: "0x02"

  - id: max_power
    type: float
    restore_value: true
    initial_value: "0.0"

  - id: power_value
    type: float
    restore_value: true
    initial_value: "0.0"

  - id: load_resistance
    type: float
    restore_value: no
    initial_value: '26.5'

  - id: manual_mode
    type: bool
    initial_value: 'false'

switch:
  - platform: template
    name: "${device_name}_manual_mode"
    id: manual_mode_switch
    restore_mode: 'RESTORE_DEFAULT_OFF'
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(manual_mode) = true;
          ESP_LOGI("mode", "Manual mode enabled");
    turn_off_action:
      - lambda: |-
          id(manual_mode) = false;
          ESP_LOGI("mode", "Auto mode enabled");

number:
  - platform: template
    name: "${device_name}_max_power"
    id: max_power_input
    min_value: 0
    max_value: 3680
    step: 1
    optimistic: true
    set_action:
      - lambda: |-
          id(max_power) = x;
          ESP_LOGI("router", "Max router power set to %.0f W", x);

  - platform: template
    name: "${device_name}_power"
    id: power
    min_value: 0
    max_value: 3680
    step: 1
    optimistic: true
    set_action:
      - lambda: |-
          float power = x;

          // Clamp to dynamic max power
          if (power > id(max_power)) {
            power = id(max_power);
          }
          id(power_value) = power;

          // calculate DAC value based on dynamic maximum power
          uint16_t data = (uint16_t)((power / id(max_power)) * 32767.0f);

          // 15-bit DAC requires shifting one bit to the left
          data <<= 1;

          uint8_t buf[3] = {id(dac_duty_cycle_reg), (uint8_t)(data & 0xFF), (uint8_t)(data >> 8)};

          // send DAC data via I2C
          auto err = id(i2cbus).write(id(dac_addr_reg), buf, 3);
          if (err == esphome::i2c::ERROR_OK) {
            // calculate approximate output voltage for logging
            float volts = (power / id(max_power)) * 10.0f;
            ESP_LOGI("dac", "DAC output set to %.2f V for %.1f W (data=%d)", volts, power, data);
          } else {
            ESP_LOGW("dac", "I2C write error: %d", (int)err);
          }
